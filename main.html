<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Интерполятор кадров с автоматическим морфингом</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/@fix-webm-duration/fix@1.0.6/dist/fix-webm-duration.min.js"></script>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState, useRef, useEffect } = React;
        
        // Автоматическое определение ключевых точек
        const detectKeyPoints = (img, gridSize = 5) => {
            const points = [];
            
            // Углы
            points.push({ x: 0, y: 0 });
            points.push({ x: 1, y: 0 });
            points.push({ x: 1, y: 1 });
            points.push({ x: 0, y: 1 });
            
            // Сетка точек
            for (let i = 1; i < gridSize; i++) {
                for (let j = 1; j < gridSize; j++) {
                    points.push({
                        x: i / gridSize,
                        y: j / gridSize
                    });
                }
            }
            
            // Центральные точки на краях
            for (let i = 1; i < gridSize; i++) {
                points.push({ x: i / gridSize, y: 0 });
                points.push({ x: i / gridSize, y: 1 });
                points.push({ x: 0, y: i / gridSize });
                points.push({ x: 1, y: i / gridSize });
            }
            
            return points;
        };
        
        // Исправленная функция проверки точки в описанной окружности
        const inCircumcircle = (point, triangle) => {
            const [ax, ay] = triangle[0];
            const [bx, by] = triangle[1];
            const [cx, cy] = triangle[2];
            const [dx, dy] = point;
            
            const ax_dx = ax - dx;
            const ay_dy = ay - dy;
            const bx_dx = bx - dx;
            const by_dy = by - dy;
            const cx_dx = cx - dx;
            const cy_dy = cy - dy;
            
            const det = (ax_dx * ax_dx + ay_dy * ay_dy) * (bx_dx * cy_dy - cx_dx * by_dy) -
                        (bx_dx * bx_dx + by_dy * by_dy) * (ax_dx * cy_dy - cx_dx * ay_dy) +
                        (cx_dx * cx_dx + cy_dy * cy_dy) * (ax_dx * by_dy - bx_dx * ay_dy);
            
            return det > 0;
        };
        
        const hasEdge = (triangle, edge) => {
            const edges = [
                [triangle[0], triangle[1]],
                [triangle[1], triangle[2]],
                [triangle[2], triangle[0]]
            ];
            
            return edges.some(e => 
                (e[0] === edge[0] && e[1] === edge[1]) || 
                (e[0] === edge[1] && e[1] === edge[0])
            );
        };
        
        // Улучшенная триангуляция Делоне
        const delaunayTriangulate = (points) => {
            if (points.length < 3) return [];
            
            const minX = Math.min(...points.map(p => p[0]));
            const minY = Math.min(...points.map(p => p[1]));
            const maxX = Math.max(...points.map(p => p[0]));
            const maxY = Math.max(...points.map(p => p[1]));
            
            const dx = maxX - minX;
            const dy = maxY - minY;
            const deltaMax = Math.max(dx, dy) * 2;
            const midx = (minX + maxX) / 2;
            const midy = (minY + maxY) / 2;
            
            const p1 = [midx - 20 * deltaMax, midy - deltaMax];
            const p2 = [midx, midy + 20 * deltaMax];
            const p3 = [midx + 20 * deltaMax, midy - deltaMax];
            
            const triangles = [[p1, p2, p3]];
            
            for (const point of points) {
                const badTriangles = [];
                
                for (const triangle of triangles) {
                    if (inCircumcircle(point, triangle)) {
                        badTriangles.push(triangle);
                    }
                }
                
                const polygon = [];
                
                for (const triangle of badTriangles) {
                    for (let i = 0; i < 3; i++) {
                        const edge = [triangle[i], triangle[(i + 1) % 3]];
                        
                        let isShared = false;
                        for (const other of badTriangles) {
                            if (other === triangle) continue;
                            if (hasEdge(other, edge)) {
                                isShared = true;
                                break;
                            }
                        }
                        
                        if (!isShared) {
                            polygon.push(edge);
                        }
                    }
                }
                
                for (const bad of badTriangles) {
                    const index = triangles.indexOf(bad);
                    if (index > -1) triangles.splice(index, 1);
                }
                
                for (const edge of polygon) {
                    triangles.push([edge[0], edge[1], point]);
                }
            }
            
            // Фильтруем треугольники, содержащие вершины супертреугольника
            const finalTriangles = triangles.filter(triangle => {
                return !triangle.some(vertex => {
                    const [vx, vy] = vertex;
                    return (vx === p1[0] && vy === p1[1]) ||
                           (vx === p2[0] && vy === p2[1]) ||
                           (vx === p3[0] && vy === p3[1]);
                });
            });
            
            const indices = [];
            for (const triangle of finalTriangles) {
                for (const vertex of triangle) {
                    const index = points.findIndex(p => 
                        Math.abs(p[0] - vertex[0]) < 0.001 && 
                        Math.abs(p[1] - vertex[1]) < 0.001
                    );
                    if (index !== -1) indices.push(index);
                }
            }
            
            return indices;
        };
        
        const Upload = () => (
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4M17 8l-5-5-5 5M12 3v12"/>
            </svg>
        );
        
        const Play = () => (
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <polygon points="5 3 19 12 5 21 5 3"/>
            </svg>
        );
        
        const Pause = () => (
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/>
            </svg>
        );
        
        const Download = () => (
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4M7 10l5 5 5-5M12 15V3"/>
            </svg>
        );
        
        const Plus = () => (
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/>
            </svg>
        );
        
        const Trash2 = () => (
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
            </svg>
        );

        const FrameInterpolator = () => {
          const [keyframes, setKeyframes] = useState([]);
          const [framesBetween, setFramesBetween] = useState(10);
          const [fps, setFps] = useState(24);
          const [easingType, setEasingType] = useState('linear');
          const [interpolatedFrames, setInterpolatedFrames] = useState([]);
          const [isPlaying, setIsPlaying] = useState(false);
          const [currentFrame, setCurrentFrame] = useState(0);
          const [downloadAsZip, setDownloadAsZip] = useState(false);
          const [useMorphing, setUseMorphing] = useState(true);
          const [gridSize, setGridSize] = useState(5);
          const [isGenerating, setIsGenerating] = useState(false);
          const [outputWidth, setOutputWidth] = useState(1920);
          const [outputHeight, setOutputHeight] = useState(1080);
          const [isDownloadingVideo, setIsDownloadingVideo] = useState(false);
          const canvasRef = useRef(null);
          const animationRef = useRef(null);
          const lastFrameTimeRef = useRef(0);
          const recorderRef = useRef(null);

          const loadImage = (file) => {
            return new Promise((resolve, reject) => {
              const reader = new FileReader();
              reader.onload = (e) => {
                const img = new Image();
                img.onload = () => resolve(img);
                img.onerror = () => reject(new Error(`Ошибка загрузки: ${file.name}`));
                img.src = e.target.result;
              };
              reader.onerror = () => reject(new Error(`Ошибка чтения: ${file.name}`));
              reader.readAsDataURL(file);
            });
          };

          const handleImageUpload = async (e) => {
            const files = Array.from(e.target.files);
            try {
              const images = await Promise.all(files.map(loadImage));
              const newKeyframes = images.map((img, idx) => ({
                id: Date.now() + idx,
                image: img,
                frameNumber: keyframes.length > 0 ? keyframes[keyframes.length - 1].frameNumber + framesBetween + 1 : 0
              }));
              setKeyframes(prev => [...prev, ...newKeyframes]);
              
              if (keyframes.length === 0 && images.length > 0) {
                setOutputWidth(images[0].width);
                setOutputHeight(images[0].height);
              }
            } catch (err) {
              alert(err.message);
            }
          };

          const removeKeyframe = (id) => {
            setKeyframes(prev => prev.filter(kf => kf.id !== id));
          };

          const easingFunctions = {
            linear: (t) => t,
            easeInQuad: (t) => t * t,
            easeOutQuad: (t) => t * (2 - t),
            easeInOutQuad: (t) => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t,
            easeInCubic: (t) => t * t * t,
            easeOutCubic: (t) => (--t) * t * t + 1,
          };

          const resizeImageToCanvas = (img, width, height) => {
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d', { alpha: false });
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            
            const scaleX = width / img.width;
            const scaleY = height / img.height;
            const scale = Math.max(scaleX, scaleY);
            
            const scaledWidth = img.width * scale;
            const scaledHeight = img.height * scale;
            const x = (width - scaledWidth) / 2;
            const y = (height - scaledHeight) / 2;
            
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, width, height);
            ctx.drawImage(img, x, y, scaledWidth, scaledHeight);
            
            return canvas;
          };

          const interpolatePixelsAdvanced = (img1, img2, ratio, easing) => {
            const canvas1 = resizeImageToCanvas(img1, outputWidth, outputHeight);
            const canvas2 = resizeImageToCanvas(img2, outputWidth, outputHeight);

            const canvas = document.createElement('canvas');
            canvas.width = outputWidth;
            canvas.height = outputHeight;
            const ctx = canvas.getContext('2d', { alpha: false });

            const easedRatio = easingFunctions[easing](ratio);

            const ctx1 = canvas1.getContext('2d');
            const ctx2 = canvas2.getContext('2d');
            
            const imgData1 = ctx1.getImageData(0, 0, outputWidth, outputHeight);
            const imgData2 = ctx2.getImageData(0, 0, outputWidth, outputHeight);
            
            const data1 = imgData1.data;
            const data2 = imgData2.data;
            const interpolatedData = new Uint8ClampedArray(data1.length);

            for (let i = 0; i < data1.length; i += 4) {
              interpolatedData[i] = Math.round(data1[i] + (data2[i] - data1[i]) * easedRatio);
              interpolatedData[i + 1] = Math.round(data1[i + 1] + (data2[i + 1] - data1[i + 1]) * easedRatio);
              interpolatedData[i + 2] = Math.round(data1[i + 2] + (data2[i + 2] - data1[i + 2]) * easedRatio);
              interpolatedData[i + 3] = 255;
            }

            const imgData = new ImageData(interpolatedData, outputWidth, outputHeight);
            ctx.putImageData(imgData, 0, 0);
            return canvas;
          };

          const interpolateMorphing = (img1, img2, ratio, gridSize) => {
            try {
              const points1 = detectKeyPoints(img1, gridSize);
              const points2 = detectKeyPoints(img2, gridSize);

              if (points1.length < 3) {
                return interpolatePixelsAdvanced(img1, img2, ratio, easingType);
              }

              const triangulatedPoints = points1.map(p => [p.x * outputWidth, p.y * outputHeight]);
              const triangles = delaunayTriangulate(triangulatedPoints);
              
              if (!triangles.length) {
                return interpolatePixelsAdvanced(img1, img2, ratio, easingType);
              }

              const geometry = new THREE.BufferGeometry();

              const positions1 = new Float32Array(points1.length * 3);
              const positions2 = new Float32Array(points1.length * 3);
              const uvs = new Float32Array(points1.length * 2);

              for (let i = 0; i < points1.length; i++) {
                // Исправленные координаты для Three.js
                positions1[i * 3] = (points1[i].x * 2 - 1);
                positions1[i * 3 + 1] = -(points1[i].y * 2 - 1); // Инверсия Y
                positions1[i * 3 + 2] = 0;

                positions2[i * 3] = (points2[i].x * 2 - 1);
                positions2[i * 3 + 1] = -(points2[i].y * 2 - 1); // Инверсия Y
                positions2[i * 3 + 2] = 0;

                uvs[i * 2] = points1[i].x;
                uvs[i * 2 + 1] = points1[i].y;
              }

              geometry.setAttribute('position', new THREE.BufferAttribute(positions1, 3));
              geometry.setAttribute('uv', new THREE.BufferAttribute(uvs, 2));
              geometry.setIndex(new THREE.BufferAttribute(new Uint32Array(triangles), 1));
              geometry.morphAttributes.position = [new THREE.BufferAttribute(positions2, 3)];

              const canvas1 = resizeImageToCanvas(img1, outputWidth, outputHeight);
              const canvas2 = resizeImageToCanvas(img2, outputWidth, outputHeight);
              
              const texture1 = new THREE.CanvasTexture(canvas1);
              texture1.minFilter = THREE.LinearFilter;
              texture1.magFilter = THREE.LinearFilter;
              
              const texture2 = new THREE.CanvasTexture(canvas2);
              texture2.minFilter = THREE.LinearFilter;
              texture2.magFilter = THREE.LinearFilter;

              const material = new THREE.ShaderMaterial({
                uniforms: {
                  texture1: { value: texture1 },
                  texture2: { value: texture2 },
                  ratio: { value: ratio },
                  morphInfluence: { value: ratio }
                },
                vertexShader: `
                  uniform float morphInfluence;
                  attribute vec3 morphTarget0;
                  varying vec2 vUv;
                  
                  void main() {
                    vec3 morphed = mix(position, morphTarget0, morphInfluence);
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(morphed, 1.0);
                    vUv = uv;
                  }
                `,
                fragmentShader: `
                  uniform sampler2D texture1;
                  uniform sampler2D texture2;
                  uniform float ratio;
                  varying vec2 vUv;
                  
                  void main() {
                    vec4 color1 = texture2D(texture1, vUv);
                    vec4 color2 = texture2D(texture2, vUv);
                    gl_FragColor = mix(color1, color2, ratio);
                  }
                `
              });

              const mesh = new THREE.Mesh(geometry, material);

              const scene = new THREE.Scene();
              scene.background = new THREE.Color(0x000000);
              scene.add(mesh);

              const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 10);
              camera.position.z = 1;

              const renderer = new THREE.WebGLRenderer({ 
                antialias: true, 
                alpha: false,
                preserveDrawingBuffer: true
              });
              renderer.setSize(outputWidth, outputHeight);
              renderer.setClearColor(0x000000, 1);

              renderer.render(scene, camera);

              const outputCanvas = document.createElement('canvas');
              outputCanvas.width = outputWidth;
              outputCanvas.height = outputHeight;
              const ctx = outputCanvas.getContext('2d', { alpha: false });
              ctx.fillStyle = '#000000';
              ctx.fillRect(0, 0, outputWidth, outputHeight);
              ctx.drawImage(renderer.domElement, 0, 0);

              // Правильная очистка ресурсов
              texture1.dispose();
              texture2.dispose();
              geometry.dispose();
              material.dispose();
              renderer.dispose();
              scene.remove(mesh);

              return outputCanvas;
            } catch (err) {
              console.error('Ошибка морфинга:', err);
              return interpolatePixelsAdvanced(img1, img2, ratio, easingType);
            }
          };

          const generateFrames = async () => {
            if (keyframes.length < 2) {
              alert('Загрузите минимум 2 ключевых кадра');
              return;
            }

            setIsGenerating(true);
            setInterpolatedFrames([]);
            
            await new Promise(resolve => setTimeout(resolve, 100));

            try {
              const allFrames = [];
              
              for (let i = 0; i < keyframes.length - 1; i++) {
                const startFrame = keyframes[i];
                const endFrame = keyframes[i + 1];
                
                const startCanvas = resizeImageToCanvas(startFrame.image, outputWidth, outputHeight);
                allFrames.push({ canvas: startCanvas, isKeyframe: true });
                
                for (let j = 1; j <= framesBetween; j++) {
                  const ratio = j / (framesBetween + 1);
                  
                  let canvas;
                  if (useMorphing) {
                    canvas = interpolateMorphing(startFrame.image, endFrame.image, ratio, gridSize);
                  } else {
                    canvas = interpolatePixelsAdvanced(startFrame.image, endFrame.image, ratio, easingType);
                  }
                  
                  allFrames.push({ canvas, isKeyframe: false });
                  
                  if (j % 3 === 0) {
                    await new Promise(resolve => setTimeout(resolve, 0));
                  }
                }
              }
              
              const lastFrame = keyframes[keyframes.length - 1];
              const lastCanvas = resizeImageToCanvas(lastFrame.image, outputWidth, outputHeight);
              allFrames.push({ canvas: lastCanvas, isKeyframe: true });
              
              setInterpolatedFrames(allFrames);
              setCurrentFrame(0);
            } catch (err) {
              console.error('Ошибка генерации:', err);
              alert('Ошибка генерации кадров: ' + err.message);
            } finally {
              setIsGenerating(false);
            }
          };

          const drawFrame = (frameIndex, showOverlay = true) => {
            if (!canvasRef.current || !interpolatedFrames[frameIndex]) return;
            
            const canvas = canvasRef.current;
            const ctx = canvas.getContext('2d');
            const frame = interpolatedFrames[frameIndex];
            
            if (canvas.width !== frame.canvas.width || canvas.height !== frame.canvas.height) {
              canvas.width = frame.canvas.width;
              canvas.height = frame.canvas.height;
            }
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(frame.canvas, 0, 0);
            
            if (showOverlay) {
              ctx.fillStyle = frame.isKeyframe ? '#ef4444' : '#3b82f6';
              ctx.font = 'bold 24px Arial';
              ctx.strokeStyle = 'white';
              ctx.lineWidth = 4;
              const text = `Кадр ${frameIndex + 1}/${interpolatedFrames.length}${frame.isKeyframe ? ' [KEY]' : ''}`;
              ctx.strokeText(text, 15, 40);
              ctx.fillText(text, 15, 40);
            }
          };

          useEffect(() => {
            if (interpolatedFrames.length > 0 && !isDownloadingVideo) {
              drawFrame(currentFrame, true);
            }
          }, [currentFrame, interpolatedFrames, isDownloadingVideo]);

          useEffect(() => {
            if (isPlaying && interpolatedFrames.length > 0) {
              const frameDuration = 1000 / fps;
              let frame = currentFrame;
              
              const animate = (timestamp) => {
                if (!isPlaying) return;
                
                if (!lastFrameTimeRef.current) {
                  lastFrameTimeRef.current = timestamp;
                }
                
                const elapsed = timestamp - lastFrameTimeRef.current;
                
                if (elapsed >= frameDuration) {
                  // Показываем надпись только если НЕ идет запись видео
                  drawFrame(frame, !isDownloadingVideo);
                  frame = (frame + 1) % interpolatedFrames.length;
                  setCurrentFrame(frame);
                  lastFrameTimeRef.current = timestamp;
                  
                  if (frame === 0) {
                    setIsPlaying(false);
                    lastFrameTimeRef.current = 0;
                    if (isDownloadingVideo && recorderRef.current) {
                      recorderRef.current.stop();
                      setIsDownloadingVideo(false);
                      recorderRef.current = null;
                    }
                    return;
                  }
                }
                
                animationRef.current = requestAnimationFrame(animate);
              };
              
              animationRef.current = requestAnimationFrame(animate);
              
              return () => {
                if (animationRef.current) {
                  cancelAnimationFrame(animationRef.current);
                }
              };
            } else {
              lastFrameTimeRef.current = 0;
            }
          }, [isPlaying, interpolatedFrames, fps, isDownloadingVideo]);

          const playAnimation = () => {
            if (interpolatedFrames.length === 0 || isPlaying || isDownloadingVideo) return;
            setIsPlaying(true);
          };

          const stopAnimation = () => {
            setIsPlaying(false);
            if (animationRef.current) {
              cancelAnimationFrame(animationRef.current);
            }
            lastFrameTimeRef.current = 0;
          };

          const downloadFrames = async () => {
            if (interpolatedFrames.length === 0) {
              alert('Нет кадров для скачивания');
              return;
            }

            if (downloadAsZip) {
              const zip = new JSZip();
              const blobsPromises = interpolatedFrames.map((frame, index) =>
                new Promise((resolve) => {
                  frame.canvas.toBlob((blob) => {
                    resolve({ index, blob });
                  }, 'image/png');
                })
              );

              const blobs = await Promise.all(blobsPromises);
              blobs.forEach(({ index, blob }) => {
                zip.file(`frame_${String(index).padStart(4, '0')}.png`, blob);
              });

              const zipBlob = await zip.generateAsync({ type: 'blob' });
              const url = URL.createObjectURL(zipBlob);
              const a = document.createElement('a');
              a.href = url;
              a.download = 'frames.zip';
              a.click();
              URL.revokeObjectURL(url);
            } else {
              interpolatedFrames.forEach((frame, index) => {
                frame.canvas.toBlob((blob) => {
                  const url = URL.createObjectURL(blob);
                  const a = document.createElement('a');
                  a.href = url;
                  a.download = `frame_${String(index).padStart(4, '0')}.png`;
                  a.click();
                  URL.revokeObjectURL(url);
                }, 'image/png');
              });
            }
          };

          const downloadVideo = async () => {
            if (interpolatedFrames.length === 0 || isPlaying || isGenerating || isDownloadingVideo) {
              alert('Нет кадров или процесс занят');
              return;
            }

            const canvas = canvasRef.current;
            if (!canvas) return;

            // Сначала устанавливаем флаг записи, потом рисуем первый кадр без надписи
            setIsDownloadingVideo(true);
            await new Promise(resolve => setTimeout(resolve, 100));
            
            // Рисуем первый кадр без надписи
            drawFrame(0, false);
            await new Promise(resolve => setTimeout(resolve, 100));

            const stream = canvas.captureStream(fps);
            const chunks = [];

            recorderRef.current = new MediaRecorder(stream, { mimeType: 'video/webm;codecs=vp9' });

            recorderRef.current.ondataavailable = (e) => {
              if (e.data.size > 0) chunks.push(e.data);
            };

            recorderRef.current.onstop = async () => {
              const expectedDuration = interpolatedFrames.length * (1000 / fps);
              const blob = new Blob(chunks, { type: 'video/webm' });
              
              let finalBlob = blob;
              if (typeof ysFixWebmDuration !== 'undefined') {
                try {
                  finalBlob = await ysFixWebmDuration(blob, expectedDuration, { logger: false });
                } catch (err) {
                  console.warn('Не удалось исправить длительность видео:', err);
                }
              }
              
              const url = URL.createObjectURL(finalBlob);
              const a = document.createElement('a');
              a.href = url;
              a.download = 'animation.webm';
              a.click();
              URL.revokeObjectURL(url);
            };

            recorderRef.current.start();
            setCurrentFrame(0);
            setIsPlaying(true);
          };

          return (
            <div className="min-h-screen bg-gradient-to-br from-purple-50 to-blue-50 p-4 md:p-8">
              <div className="max-w-7xl mx-auto">
                <h1 className="text-3xl md:text-4xl font-bold text-gray-800 mb-2">Интерполятор кадров с автоматическим морфингом</h1>
                <p className="text-gray-600 mb-6 md:mb-8">Загрузите ключевые кадры - точки для морфинга будут найдены автоматически</p>
                
                <div className="grid grid-cols-1 lg:grid-cols-3 gap-4 md:gap-6">
                  <div className="lg:col-span-1 space-y-4">
                    <div className="bg-white rounded-lg shadow-lg p-4 md:p-6">
                      <h2 className="text-lg md:text-xl font-semibold mb-4">Настройки</h2>
                      
                      <label className="flex items-center justify-center w-full p-4 border-2 border-dashed border-gray-300 rounded-lg cursor-pointer hover:border-purple-500 transition">
                        <Upload />
                        <span className="ml-2 text-sm md:text-base">Загрузить изображения</span>
                        <input
                          type="file"
                          multiple
                          accept="image/*"
                          onChange={handleImageUpload}
                          className="hidden"
                        />
                      </label>
                      
                      <div className="mt-4 space-y-2 max-h-64 overflow-y-auto">
                        {keyframes.map((kf, idx) => (
                          <div key={kf.id} className="bg-gray-50 p-3 rounded flex items-center justify-between">
                            <div className="flex items-center gap-3">
                              <img 
                                src={kf.image.src} 
                                alt={`Кадр ${idx + 1}`}
                                className="w-16 h-16 object-cover rounded"
                              />
                              <span className="text-sm font-medium">Кадр {idx + 1}</span>
                            </div>
                            <button
                              onClick={() => removeKeyframe(kf.id)}
                              className="text-red-500 hover:text-red-700 transition"
                              aria-label="Удалить кадр"
                            >
                              <Trash2 />
                            </button>
                          </div>
                        ))}
                      </div>

                      <div className="mt-6 space-y-4">
                        <div>
                          <label className="block text-sm font-medium mb-2">
                            Разрешение выходного видео
                          </label>
                          <div className="grid grid-cols-2 gap-2">
                            <input
                              type="number"
                              value={outputWidth}
                              onChange={(e) => setOutputWidth(parseInt(e.target.value) || 1920)}
                              className="p-2 border rounded text-sm"
                              placeholder="Ширина"
                            />
                            <input
                              type="number"
                              value={outputHeight}
                              onChange={(e) => setOutputHeight(parseInt(e.target.value) || 1080)}
                              className="p-2 border rounded text-sm"
                              placeholder="Высота"
                            />
                          </div>
                          <div className="mt-2 flex gap-2 flex-wrap">
                            <button onClick={() => { setOutputWidth(1920); setOutputHeight(1080); }} className="text-xs bg-gray-200 px-2 py-1 rounded hover:bg-gray-300">1920×1080</button>
                            <button onClick={() => { setOutputWidth(1280); setOutputHeight(720); }} className="text-xs bg-gray-200 px-2 py-1 rounded hover:bg-gray-300">1280×720</button>
                            <button onClick={() => { setOutputWidth(3840); setOutputHeight(2160); }} className="text-xs bg-gray-200 px-2 py-1 rounded hover:bg-gray-300">3840×2160</button>
                          </div>
                        </div>
                        
                        <div>
                          <label className="block text-sm font-medium mb-2">
                            Кадров между ключевыми: {framesBetween}
                          </label>
                          <input
                            type="range"
                            min="1"
                            max="60"
                            value={framesBetween}
                            onChange={(e) => setFramesBetween(parseInt(e.target.value))}
                            className="w-full"
                          />
                        </div>

                        <div>
                          <label className="block text-sm font-medium mb-2">
                            FPS воспроизведения: {fps}
                          </label>
                          <input
                            type="range"
                            min="1"
                            max="60"
                            value={fps}
                            onChange={(e) => setFps(parseInt(e.target.value))}
                            className="w-full"
                          />
                          <div className="mt-2 flex gap-2 flex-wrap">
                            <button onClick={() => setFps(24)} className="text-xs bg-gray-200 px-2 py-1 rounded hover:bg-gray-300">24 fps</button>
                            <button onClick={() => setFps(30)} className="text-xs bg-gray-200 px-2 py-1 rounded hover:bg-gray-300">30 fps</button>
                            <button onClick={() => setFps(60)} className="text-xs bg-gray-200 px-2 py-1 rounded hover:bg-gray-300">60 fps</button>
                          </div>
                        </div>

                        <div>
                          <label className="block text-sm font-medium mb-2">
                            Тип сглаживания:
                          </label>
                          <select
                            value={easingType}
                            onChange={(e) => setEasingType(e.target.value)}
                            className="w-full p-2 border rounded text-sm"
                          >
                            <option value="linear">Линейное</option>
                            <option value="easeInQuad">Ease In Quad</option>
                            <option value="easeOutQuad">Ease Out Quad</option>
                            <option value="easeInOutQuad">Ease In Out Quad</option>
                            <option value="easeInCubic">Ease In Cubic</option>
                            <option value="easeOutCubic">Ease Out Cubic</option>
                          </select>
                        </div>

                        <div>
                          <label className="flex items-center cursor-pointer">
                            <input
                              type="checkbox"
                              checked={useMorphing}
                              onChange={(e) => setUseMorphing(e.target.checked)}
                              className="mr-2 w-4 h-4"
                            />
                            <span className="text-sm">Использовать морфинг</span>
                          </label>
                          {useMorphing && (
                            <div className="mt-3">
                              <label className="block text-sm font-medium mb-2">
                                Плотность сетки морфинга: {gridSize}×{gridSize}
                              </label>
                              <input
                                type="range"
                                min="3"
                                max="10"
                                value={gridSize}
                                onChange={(e) => setGridSize(parseInt(e.target.value))}
                                className="w-full"
                              />
                              <p className="mt-2 text-xs text-gray-500">
                                Больше точек = более плавный морфинг, но медленнее генерация
                              </p>
                            </div>
                          )}
                        </div>
                      </div>
                      
                      <button
                        onClick={generateFrames}
                        disabled={keyframes.length < 2 || isGenerating}
                        className="w-full mt-6 bg-purple-600 text-white py-3 rounded-lg hover:bg-purple-700 disabled:bg-gray-400 disabled:cursor-not-allowed transition flex items-center justify-center text-sm md:text-base font-medium"
                        aria-label="Создать анимацию"
                      >
                        {isGenerating ? (
                          <>
                            <span className="animate-spin mr-2">⏳</span>
                            Генерация...
                          </>
                        ) : (
                          <>
                            <Plus />
                            <span className="ml-2">Создать анимацию</span>
                          </>
                        )}
                      </button>
                    </div>
                    
                    {interpolatedFrames.length > 0 && (
                      <div className="bg-white rounded-lg shadow-lg p-4 md:p-6">
                        <h3 className="text-lg font-semibold mb-4">Управление</h3>
                        
                        <button
                          onClick={isPlaying ? stopAnimation : playAnimation}
                          className={`w-full ${isPlaying ? 'bg-orange-600 hover:bg-orange-700' : 'bg-green-600 hover:bg-green-700'} text-white py-3 rounded-lg transition mb-3 flex items-center justify-center text-sm md:text-base font-medium`}
                          aria-label={isPlaying ? 'Остановить анимацию' : 'Воспроизвести анимацию'}
                          disabled={isDownloadingVideo}
                        >
                          {isPlaying ? <Pause /> : <Play />}
                          <span className="ml-2">{isPlaying ? 'Пауза' : 'Воспроизвести'}</span>
                        </button>

                        <div className="mb-3">
                          <label className="flex items-center cursor-pointer">
                            <input
                              type="checkbox"
                              checked={downloadAsZip}
                              onChange={(e) => setDownloadAsZip(e.target.checked)}
                              className="mr-2 w-4 h-4"
                            />
                            <span className="text-sm">Скачать в ZIP-архиве</span>
                          </label>
                        </div>
                        
                        <button
                          onClick={downloadFrames}
                          className="w-full bg-blue-600 text-white py-3 rounded-lg hover:bg-blue-700 transition flex items-center justify-center text-sm md:text-base font-medium"
                          aria-label="Скачать все кадры"
                          disabled={isDownloadingVideo}
                        >
                          <Download />
                          <span className="ml-2">Скачать кадры ({interpolatedFrames.length})</span>
                        </button>

                        <button
                          onClick={downloadVideo}
                          className="w-full mt-3 bg-indigo-600 text-white py-3 rounded-lg hover:bg-indigo-700 transition flex items-center justify-center text-sm md:text-base font-medium"
                          aria-label="Скачать видео"
                          disabled={isDownloadingVideo}
                        >
                          {isDownloadingVideo ? (
                            <>
                              <span className="animate-spin mr-2">⏳</span>
                              Запись...
                            </>
                          ) : (
                            <>
                              <Download />
                              <span className="ml-2">Скачать видео</span>
                            </>
                          )}
                        </button>
                        
                        <div className="mt-4">
                          <label className="block text-sm font-medium mb-2">
                            Кадр: {currentFrame + 1} / {interpolatedFrames.length}
                          </label>
                          <input
                            type="range"
                            min="0"
                            max={interpolatedFrames.length - 1}
                            value={currentFrame}
                            onChange={(e) => {
                              stopAnimation();
                              setCurrentFrame(parseInt(e.target.value));
                            }}
                            className="w-full"
                          />
                        </div>
                        
                        <div className="mt-4 p-3 bg-gray-50 rounded text-xs md:text-sm text-gray-600 space-y-1">
                          <p className="flex justify-between">
                            <span>Всего кадров:</span>
                            <span className="font-semibold">{interpolatedFrames.length}</span>
                          </p>
                          <p className="flex justify-between">
                            <span>Ключевых:</span>
                            <span className="font-semibold">{keyframes.length}</span>
                          </p>
                          <p className="flex justify-between">
                            <span>Интерполированных:</span>
                            <span className="font-semibold">{interpolatedFrames.length - keyframes.length}</span>
                          </p>
                          <p className="flex justify-between">
                            <span>Длительность:</span>
                            <span className="font-semibold">{(interpolatedFrames.length / fps).toFixed(2)} сек</span>
                          </p>
                          <p className="flex justify-between">
                            <span>Разрешение:</span>
                            <span className="font-semibold">{outputWidth}×{outputHeight}</span>
                          </p>
                        </div>
                      </div>
                    )}
                  </div>
                  
                  <div className="lg:col-span-2">
                    <div className="bg-white rounded-lg shadow-lg p-4 md:p-6">
                      <h2 className="text-lg md:text-xl font-semibold mb-4">Превью анимации</h2>
                      <div className="flex justify-center items-center bg-gray-900 rounded-lg p-4 min-h-[300px] md:min-h-[500px]">
                        {interpolatedFrames.length > 0 ? (
                          <canvas
                            ref={canvasRef}
                            className="max-w-full max-h-[700px] rounded shadow-2xl"
                          />
                        ) : (
                          <div className="text-center text-gray-400 p-4">
                            <svg className="w-20 h-20 mx-auto mb-4 text-gray-300" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z" />
                            </svg>
                            <p className="mb-2 text-lg">Загрузите ключевые кадры</p>
                            <p className="text-sm">и нажмите "Создать анимацию"</p>
                          </div>
                        )}
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<FrameInterpolator />);
    </script>
</body>
</html>
